---
marp: true
---

## 12장 컨테이너 오케스트레이션: 도커 스웜과 쿠버네티스
12.1 컨테이너 오케스트레이션 도구란?
12.2 도커 스웜으로 클러스터 만들기
12.3 도커 스웜 서비스로 애플리케이션 실행하기
12.4 클러스터 환경에서 네트워크 트래픽 관리하기
12.5 도커 스웜과 쿠버네티스 중 무엇을 사용할까?

---

### 오케스트레이션 도구의 필요성
`도커 컴포즈` - 단일 도커 호스트에서 컨테이너를 실행하기 위한 도구

단일 호스트 환경에서는 고가용성이 보장되지 않음. 
--> 대량의 트래픽과 고가용성을 얻기 위해 여러 대의 도커 호스트로 구성된 운영환경을 구축한다. 

`오케스트레이션 도구` - **여러 대의 도커 호스트와 컨테이너를 관리해주는 '관리 레이어'**. 
여러 대의 서버를 하나의 '클러스터'로 구성하며, 클러스터를 자동으로 관리.
컨테이너를 관리하고, 서비스를 제공하기 위한 작업을 여러 대의 호스트 컴퓨터에 분배하고, 네트워크 트래픽 부하를 고르게 분산시키고, 상태가 불량한 컨테이너를 새 컨테이너로 교체하는 일을 담당.

`대표적 오케이스트레이션 도구`: 도커 스웜, 쿠버네티스.

---

### 오케스트레이션 도구가 제공하는 기능
분산 데이터베이스 - 클러스터에 배포된 애플리케이션에 대한 모든 정보가 담김
스케줄러 - 어떤 컨테이너를 어떤 호스트에서 실행할지 배정
클러스터를 구성하는 호스트간에 주기적으로 연락 신호를 주고받는 시스템

그 밖에 네트워크 관련 기능, 애플리케이션 설정 기능, 데이터 저장 기능, 비밀값에 저장된 애플리케이션 설정, 공유 스토리지

### 도커 스웜으로 클러스터 만들기
```
docker swarm init # 도커 엔진을 스웜 모드로 전환
```

`도커 스웜 모드로 전환하면 생기는 일`
도커 스웜이 초기화 된다. 
매니저 역할을 맡은 단일 노드(내 컴퓨터!)를 가진 클러스터가 만들어진다.

--- 

## 클러스터의 노드 구성 - 매니저 + 워커 
클러스터에 속한 컴퓨터는 **매니저 / 워커** 중 하나의 역할을 맡게 된다.

### 매니저
클러스터를 관리하는 작업을 직접 수행하는 노드.
클러스터 데이터베이스도 매니저 노드에 저장된다. (모든 매니저 노드에 복제본이 저장됨)
사용자가 YAML 파일을 전달하기 위해 사용하는 API도 매니저 노드에서 동작한다.
컨테이너 모니터링과 스케줄링 모두 매니저 노드가 수행한다.

### 워커
매니저의 스케줄링에 따라 컨테이너를 실행하고 그 상태를 주기적으로 매니저에게 보고하는 역할을 수행. (매니저도 워커의 역할을 수행할 수는 있다.)

---

### 스웜에 노드 추가하기
스웜에 추가된 컴퓨터를 노드라고 함.
원하는 만큼 컴퓨터를 노드에 추가할 수 있음.
스웜에 노드를 추가하려면, 추가하고자 하는 컴퓨터가 스웜과 같은 네트워크 상에 있어야 함. 
스웜에 들어가기 위한 패스워드 역할을 하는 참가 토큰을 매니저로부터 발급받아야 함.

```
docker swarm join-token worker # 워커노드로 스웜에 참여
docker swarm join-token manager # 매니저노드로 스웜에 참여
docker node ls # 스웜에 참여한 노드 목록
```
앞서 docker swarm init 으로 매니저 노드 생성하고, 나머지 노드들에서 docker swam join으로 매니저/워커 역할 부여하는 식으로 클러스터를 구성/관리할 수 있다. 

---

### 도커 스웜에서의 서비스
컨테이너를 추상화한 개념. 컴포즈에서 말하는 서비스와 의미가 같다.
하나의 서비스가 여러 개의 컨테이너로 배포될 수 있다. (컨테이너와 같은 정보 - 이미지, 환경변수, 포트 등 - 로 정의됨)


도커 스웜 환경에서는 서비스를 배포하면 스웜이 대신 컨테이너를 실행해주기 때문에, 컨테이너를 직접 실행할 필요가 없다.

### 도커 스웜에서의 레플리카
서비스를 구성하는 컨테이너.
레플리카 관리는 도커 스웜이 수행한다. 즉 레플리카 컨테이너를 직접 삭제할 경우, 스웜은 레플리카가 부족하다고 판단하고 새 레플리카를 실행한다.

---

### 롤링 업데이트
모든 컨테이너 오케스트레이션 도구는 롤링 업데이트 방식을 사용해서 애플리케이션을 업데이트한다. (애플리케이션을 중단시키지 않고 점진적으로 컨테이너를 교체)

(Why good?)
신규 투입된 컨테이너의 상태를 확인하여, 문제가 확인되면 업데이트를 자동으로 중단하여 문제가 확산되는 것을 방지.
이전 버전의 서비스 정의내용이 스웜 데이터베이스에 남아있기 때문에 롤백도 용이.

```
docker service update --image {이미지명} {서비스명}
docker service update --rollback {서비스명}
```

---

```
스웜 모드의 네트워크는 표준 TCP/IP 방식
```
어플리케이션을 구성하는 여러 컴포넌트(ex. 웹, api 서버 등) 각각은 여러 개의 컨테이너에서 실행됨. 
각 컴포넌트는 도메인 네임으로 서로를 식별함.
도메인네임을 IP주소로 맵핑해주는 것이 도커 DNS 서버. 

서로 다른 노드에서 실행중인 컨테이너 간에 요청과 응답을 주고받게 하려고 물밑에서 다양한 네트워크 로직이 돌아감.

### 도커스웜의 오버레이 네트워크
클러스터에 속한 모든 노드를 연결하는 가상 네트워크.
오버레이 네트워크에 연결된 서비스는, **서비스 이름을 도메인 네임 삼아서** 다른 서비스와 통신할 수 있다. 

---

### 오버레이 네트워크 vs. 도커 네트워크
**VIP를 활용한 로드밸런싱이 가능함**

`도커 네트워크에서의 스케일링` - 도커 컴포즈에서 하나의 서비스를 여러개의 컨테이너로 스케일링할 수는 있었지만, DNS 질의 시 서비스에 해당하는 모든 컨테이너의 IP주소가 리턴되어서, 그 중 어느 IP 주소로 트래픽이 전달될지는 컨슈머에 달려 있음

`오버레이 네트워크에서의 스케일링` - 각 서비스가 여러 개의 컨테이너에서 실행되긴 하지만, DNS 질의 시 각 서비스마다 하나의 IP주소가 조회됨. 이 IP주소는 가상 IP 주소이고, 서비스에 속하는 모든 컨테이너(레플리카)가 공유하는 주소임. 이 중 어느 IP 주소로 트래픽이 라우팅되는 지는 운영체제의 네트워크 계층에서 판단하기 때문에, 네트워크 트래픽을 고르게 분배하는 로드밸런싱에 훨씬 유리함.

단, 서비스 간 통신 문제를 디버깅할 때 이를 잘 고려해야 함.

---


### 인그레스 네트워크 사용
(복잡한 상황의 등장!)
노드 중 일부 노드만 특정 서비스를 실행할 수 있음 --> 해당 서비스를 실행중인 노드들로만 관련 요청을 전달해줘야 함.
하나의 노드에서 여러 컨테이너를 실행할 수 있음 --> 즉 한 노드에서 실행중인 컨테이너 끼리도 로드 밸런싱을 해야함. 

정확하게 트래픽을 라우팅하기 위해 인그레스 네트워크를 사용한다.
1) 서비스가 공개한 포트를 모든 노드가 감시하여 외부 트래픽을 받음 (=> 모든 노드에 요청이 도달할 수 있음)
2-A) 해당 서비스를 실행하지 않는 노드에 요청이 도달하면, 요청을 처리할 수 있는 다른 노드로 요청을 포워딩 함
2-B) 처리할 수 있는 노드에 도달했는데, 컨테이너가 여러개 실행중이라면, 도커 엔진이 컨테이너 간에 요청을 고르게 분배함

이게 가능한 이유?
도커 컴포즈 - 여러 개의 컨테이너가 같은 포트를 감시하도록 할 수 없음
도커 스웜 - 인그레스 네트워크를 사용해서 이게 가능함.