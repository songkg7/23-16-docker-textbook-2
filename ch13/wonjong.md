---
marp: true
---

# Ch13. 도커 스웜으로 분산 애플리케이션 배포하기

---

## 13.1 도커 컴포즈를 사용한 운영 환경

스웜에서 가장 간단한 형태의 배포는 컴포즈 파일 그 자체

~~~

version: "3.7"

services:
  todo-web:
    image: diamol/ch06-todo-list
    ports:
      - 8080:80

~~~

컴포즈 -> 단일 서버 앱 배포
스웜 -> 동일한 파일 사용해 앱 배포 -> 레플리카 하나 실행 -> 인그레스 네트워크 통해 포트 공개
스웜에서는 앱을 배할 때 스택을 만든다.
스택 : 서비스, 네트워크, 볼륨 등 여러 개 도커 리소스 묶어 만듦

---

별도의 추가 설정 없이 컴포즈 파일만으로 스웜에 앱 배포가 가능
스웜에 노드가 두 개 이상이면 고가용성 확보
고가용성 : 서비스 레플리카를 실행 중인 노드가 고장을 일으켜도 남아있는 노드에서 대체 레플리카를 실행해 앱 복구

---

컴포즈 파일에 deploy를 추가하면 레플리카의 사용량을 제한
- 해당 속성은 스택에서만 유효
- 단일 서버의 경우 무시가 될 뿐 실행에는 문제 X

~~~
version: "3.7"

services:
  todo-web:
    image: diamol/ch06-todo-list
    ports:
      - 8080:80
    deploy:
      replicas: 2
      resources:
        limits:
          cpus: "0.50"
          memory: 100M
~~~

하나의 레플리카 : CPU 코어의 경우 코어 한 개의 50%, 메모리의 경우 100MB까지 점유 가능

---

스웜 스택은 앱을 그룹화 하는 방법으로 활용

클러스터는 일반적으로 많은 수의 앱을 실행하기 때문에 앱도 그룹으로 만들어 관리해야 함

---

## 13.2 컨피그 객체를 이용한 설정 값 관리

컨테이너에서 실행된 앱을 설정값을 컨테이너를 실행한 플랫폼에서 받아와야 함

클러스터에 저장되는 도커 컨피그(config) 객체를 이용해 운영 환경 앱에 설정값을 제공하는 방법이 있다.

동일한 도커 이미지를 사용한다. 앱의 동작만 달라진다.

컨피그 객체
- 컨테이너가 설정값을 클러스터에서 읽어올 수 있게 해 주는 강력한 기능을 가진 리소스
- 앱 배포와 설정 관리를 분리
- API 키, DB 서버 비밀번호, SSL 인증서 등 비밀값을 앱 플랫폼에 전달해야 할 때 사용

컨피그 객체는 보안이 적용돼 있지 않다. 클러스터에 접근 권한이 있다면 객체의 내용을 모두 알 수 있다.

---

다음과 같이 서비스는 컴포즈 파일에 지정된 컨피그 객체를 사용

~~~
version: "3.7"

services:
  todo-web:
    image: diamol/ch06-todo-list
    ports:
      - 8080:80
    configs:
      - source: todo-list-config
        target: /app/config/config.json

# ...

configs:
  todo-list-config:
    external: true
~~~

external 플래그는 해당 리소스가 이미 클러스터에 저장되어 있음을 의미

---

민감한 데이터는 컨피그 객체에 보관해서는 안 된다.

컨피그 객체는 암호화되지 않으며 클러스터 접근 권한이 있는 사람이면 누구든 전체 내용을 볼 수 있기 때문이다.

---

## 13.3 비밀값을 이용한 대외비 설정 정보 관리하기

비밀값은 클러스터의 관리를 받는 스웜 리소스
- 전반적으로 컨피그 객체와 비슷
- 비밀값을 사용하는 워크플로 중 비밀값이 컨테이너에 전달된 상태에서만 복호화된 비밀값을 볼 수 있다.
  - 그 외의 경우는 비밀값이 항상 암호화된 상태로 존재

비밀값은 스웜 데이터베이스에 암호화돼 저장되며 매니저 노드에서 다른 노드로 전달될 때도 암호화된 채로 전달된다.

---

~~~
services:
  todo-web:
    image: diamol/ch06-todo-list
    ports:
      - 8080:80
    configs:
      - source: todo-list-config
        target: /app/config/config.json
    secrets:
      - source: todo-list-secret
        target: /app/config/secrets.json

# ...

secrets:
  todo-list-secret:
    external: true
~~~

---

비밀값과 컨피그 객체는 매니저 노드에 위치한 분산형 DB에 저장돼 필요로 하는 어느 노드라도 사용 가능

스택은 오버레이 네트워크를 구성해 컨테이너가 어느 노드에서 실행됐는지와 무관하게 서로 통신 가능

서비스는 인그레스 네트워크를 사용해 웹 레플리카가 어느 노드에 있는 서비스 컨테이너라도 호출 가능

컨피그 객체와 비밀 값은 수정이 불가능

변경 필요시 다음 단계를 거쳐야 함

1. 변경된 내용을 담은 새로운 컨피그 객체 혹은 비밀값을 기존의 것과 다른 이름으로 만듦
2. 컴포즈 파일의 정의에 사용된 컨피그 객체 혹은 비밀값의 이름을 새로 만든 이름으로 바꾼다.
3. 변경된 컴포즈 파일로 스택을 배포한다.

---

## 13.4 스웜에서 볼륨 사용하기

볼륨은 컨테이너와 별개의 생애주기를 갖는 스토리지의 단위

볼륨은 컨테이너 외부에 존재하는 리소스

앱을 업데이트 하면 컨테이너가 교체되면서 불륨은 새 컨테이너에 연결됨

오케스트레이션 플랫폼에서도 볼륨의 개념은 동일
- 컴포즈 파일의 서비스 정의에 볼륨 마운트를 정의하면
- 레플리카에서 볼륨을 로컬 파일 시스템의 디렉터리처럼 사용할 수 있음
- 하지만 데이터가 저장되는 방식에 차이가 있음 (중요)
  - 클러스터는 여러 노드로 구성
  - 각 노드는 각각 디스크가 존재, 이 디스크에 로컬 볼륨 저장
  - 업데이트 시 데이터를 유지하는 가장 간단한 방법 = 이 로컬 볼륨 이용

---

문제 상황 : 어떤 레플리카를 대체하는 새로운 레플리카가 이전 레플리카와 다른 노드에서 실행되는 경우
- 새 레플리카는 기존 레플리카가 사용하던 로컬 볼륨에 접근할 수 없음
- 이 문제는 서비스가 데이터가 있는 특정 노드에서만 실행되게끔 고정하면 해결

방법 : 노드에 레이블 부여, 컴포즈 파일에서 해당 노드에서만 레플리카를 실행하도록 강제

---
서비스 레플리카가 실행되는 노드를 제한
~~~
services:
  todo-db:
    image: diamol/postgres:11.5
    environment:
      PGDATA: "/var/lib/postgresql/data/pgdata"
    volumes:
      - todo-db-data:/var/lib/postgresql/data
    deploy:
      replicas: 1
      resources:
        limits:
          cpus: "0.50"
          memory: 500M
      placement:
        constraints:
          - node.labels.storage == raid

# ...

volumes:
  todo-db-data:
~~~
이대로 배포하면 DB 레플리카는 스토리지 레이블이 일치하는 노드에서만 실행

---

## 13.5 클러스터는 스택을 어떻게 관리하는가?

스택이 도커 스웜 상의 리소스를 관리하는 유형

1. 인그레스 네트워크는 항상 존재. 스택은 인그레스 네트워크에서 포트 공개 여부 관리
2. 서비스는 스택의 통제를 받는다. 스택과 함께 생성되거나 업데이트되며, 스택이 제거되면 함께 제거
3. 비밀값, 컨피그 객체, 네트워크는 외부에서 관리 가능. 이들 객체는 앱 배포 전에 생성, 스택은 서비스를 이들에 연결
4. 볼륨은 외부에서 관리하거나 스택이 관리. 기본 볼륨은 스택과 생애 주기 함께 하ㅣ지만, 이름이 부여된 볼륨은 스택이 제거된 후 유지